{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>doti18n is a Python library that allows you to access localization data (YAML, JSON, XML) using dot-notation instead of dictionary lookups. </p> <p>It focuses on type safety by generating <code>.pyi</code> stubs, allowing IDEs to provide autocompletion and enabling linters to catch missing keys or other errors.</p>"},{"location":"#comparison","title":"Comparison","text":"<p>The main goal of doti18n is to replace string-based lookups with object navigation.</p> <pre><code># Traditional dictionary lookup\nlocales['en']['messages']['errors']['connection']\n\n# gettext style\n_(\"messages.errors.connection\")\n\n# doti18n style\ni18n[\"en\"].messages.errors.connection\n</code></pre>"},{"location":"#features","title":"Features","text":""},{"location":"#type-safety-autocompletion","title":"Type Safety &amp; Autocompletion","text":"<p>doti18n includes a CLI tool that scans your locale files and generates PEP 561 compatible type stubs.</p> <ul> <li>IDE Autocompletion: Editors like VS Code and PyCharm will suggest available keys as you type.</li> <li>Validation: Static analysis tools (mypy, pyright) will flag errors if you reference a key that doesn't exist in your translation files.</li> </ul>"},{"location":"#pluralization","title":"Pluralization","text":"<p>The library uses Babel for pluralization, ensuring correct rules for different languages. It supports:</p> <ul> <li>Standard CLDR plural forms (zero, one, two, few, many, other).</li> <li>Variable interpolation.</li> <li>Nested structures.</li> </ul>"},{"location":"#execution-modes","title":"Execution Modes","text":"<p>You can configure how the library handles missing keys:</p> <ul> <li>Strict Mode: Raises exceptions for invalid paths. Recommended for testing and CI/CD.</li> <li>Non-Strict Mode: Returns a safe wrapper object and logs a warning instead of crashing. Recommended for production.</li> </ul>"},{"location":"#project-status","title":"Project Status","text":"<p>Alpha Release</p> <p>This project is in the Alpha stage. The internal API and method signatures may undergo changes before the 1.0.0 release.</p>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Getting started: Installation and initial setup.</li> <li>Usage: Supported formats (YAML, JSON, XML), pluralization examples, and interpolation(formatting).</li> <li>CLI: How to generate type definitions for your project.</li> </ul>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#installation","title":"Installation","text":"<p>Install from PyPI:</p> <pre><code>pip install doti18n\n</code></pre> <p>For YAML support, install the extra dependency:</p> <pre><code>pip install doti18n[yaml]\n</code></pre> <p>Or install from source:</p> <pre><code>git clone https://github.com/darkj3suss/doti18n\ncd doti18n\npip install .\n</code></pre>"},{"location":"getting_started/#first-steps","title":"First Steps","text":"<p>Create a directory for your localization files.</p> <p>Tip</p> <p>doti18n supports YAML, JSON, and XML out of the box. You can add other formats via Custom Loaders.</p> <p>Directory Structure:</p> <pre><code>project_root/\n\u251c\u2500\u2500 locales/\n\u2502   \u251c\u2500\u2500 en.yaml\n\u2502   \u251c\u2500\u2500 fr.yaml\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 main.py\n</code></pre>"},{"location":"getting_started/#create-files","title":"Create Files","text":"YAMLJSONXML <p><code>locales/en.yaml</code>: <pre><code>hello: \"Hello World!\"\n</code></pre> <code>locales/fr.yaml</code>: <pre><code>hello: \"Bonjour le monde!\"\n</code></pre></p> <p><code>locales/en.json</code>: <pre><code>{\"hello\": \"Hello World!\"}\n</code></pre> <code>locales/fr.json</code>: <pre><code>{\"hello\": \"Bonjour le monde!\"}\n</code></pre></p> <p>Note</p> <p>The root element is ignored in XML files. See Supported Formats for details.</p> <p><code>locales/en.xml</code>: <pre><code>&lt;locale&gt;\n    &lt;hello&gt;Hello World!&lt;/hello&gt;\n&lt;/locale&gt;\n</code></pre> <code>locales/fr.xml</code>: <pre><code>&lt;locale&gt;\n    &lt;hello&gt;Bonjour le monde!&lt;/hello&gt;\n&lt;/locale&gt;\n</code></pre></p>"},{"location":"getting_started/#usage","title":"Usage","text":"<p>Load and access translations using dot-notation:</p> <pre><code>from doti18n import LocaleData\n\ni18n = LocaleData(\"locales\")\n\nprint(i18n[\"en\"].hello)  # Output: Hello World!\nprint(i18n[\"fr\"].hello)  # Output: Bonjour le monde!\n</code></pre> <p>That's it!  Check the Usage section for advanced features like pluralization, formatting, and strict mode.</p>"},{"location":"cli/lint/","title":"Linting Translations","text":""},{"location":"cli/lint/#description","title":"Description","text":"<p>The CLI tool scans your translation files for consistency issues. It compares all target locales against a \"source of truth\" (default is <code>en</code>) to detect missing keys, type mismatches, and structural differences.</p>"},{"location":"cli/lint/#example","title":"Example","text":"<p>Given the following structure:</p> <pre><code>project_root/  \n\u251c\u2500\u2500 locales/  \n\u2502   \u251c\u2500\u2500 en.yaml\n\u2502   \u2514\u2500\u2500 fr.yaml\n\u2514\u2500\u2500 main.py  \n</code></pre> <p>Content of <code>en.yaml</code> (Source): <pre><code>greeting: \"Hello, World!\"\nmenu:\n  save: \"Save\"\n  open: \"Open\"\nitems:\n  - \"Apple\"\n  - \"Banana\"\n</code></pre></p> <p>Content of <code>fr.yaml</code> (Target with errors): <pre><code># 'greeting' is missing\nmenu: \"Menu\" # Type mismatch: expected dict, got string\nitems:\n  - \"Pomme\"\n  # List length mismatch (missing 2nd item)\n</code></pre></p> <p>Run the linter: <pre><code>doti18n lint locales/\n</code></pre></p>"},{"location":"cli/lint/#results","title":"Results","text":"<p>Consistency Checks: The tool outputs logs indicating specific issues within your locale files.</p> <p>Missing Keys: Detects keys that exist in the source locale but are absent in the target.</p> <pre><code>[fr] Missing key: greeting\n[fr] Missing key: menu.save\n[fr] Missing key: menu.open\n</code></pre> <p>Type Mismatches: Ensures data types (strings, lists, dictionaries) are consistent across languages.</p> <pre><code>[fr] Type mismatch at menu: expected dict, got str\n</code></pre> <p>List Integrity: Verifies that lists have the same length and structure.</p> <pre><code>[fr] List length mismatch at items: expected 2, got 1\n</code></pre>"},{"location":"cli/lint/#options","title":"Options","text":"<p>Set source of truth: Specify which locale code should be used as the reference for validation (default is <code>en</code>). <pre><code>doti18n lint locales/ --source fr\n</code></pre></p> <p>Check ICU Syntax: Enable validation for ICU MessageFormat syntax (e.g., checking braces and placeholders). <pre><code>doti18n lint locales/ --icumf\n</code></pre></p>"},{"location":"cli/stub/","title":"Stub Generation","text":""},{"location":"cli/stub/#description","title":"Description","text":"<p>The CLI tool generates type stubs (<code>.pyi</code>) based on your translation files.  This enables static type checking and IDE autocompletion for keys and string formatting arguments.</p>"},{"location":"cli/stub/#example","title":"Example","text":"<p>Given the following structure:</p> <pre><code>project_root/  \n\u251c\u2500\u2500 locales/  \n\u2502   \u2514\u2500\u2500 en.yaml  \n\u2514\u2500\u2500 main.py  \n</code></pre> <p>Content of <code>en.yaml</code>: <pre><code>greeting: \"Hello, {name}!\"\nbasket: \"You have {0} bananas, {1} apples, and {2} oranges in your basket.\"\n</code></pre></p> <p>Run the generator: <pre><code>doti18n stub locales/\n</code></pre></p> <p>Note</p> <p>Stubs must be regenerated after any changes to localization files (adding keys, changing arguments, etc.).</p>"},{"location":"cli/stub/#results","title":"Results","text":"<p>Autocompletion: Your IDE will now suggest available keys and methods.</p>    Your browser doesn't support video  <p>Static Analysis: Type checkers (like mypy) will detect errors such as typos or mismatched formatting arguments.</p> <p>Typos:</p> <p> </p> <p>Unexpected arguments:</p> <p></p> <p>Missing arguments:</p> <p></p> <p></p> <p>Virtual Environment</p> <p>The generator writes the <code>__init__.pyi</code> file directly into the installed <code>doti18n</code> package directory. Always run this command inside a virtual environment (venv). Modifying system-wide Python packages is strongly discouraged.</p>"},{"location":"cli/stub/#options","title":"Options","text":"<p>Clean stubs: Remove previously generated type definitions. <pre><code>doti18n stub --clean\n</code></pre></p> <p>Set default locale: Specify which locale file should be used as the source of truth for generating types (default is <code>en</code>). <pre><code>doti18n stub locales/ --lang fr\n</code></pre></p>"},{"location":"integrations/django/","title":"Django","text":"<p>If you don't read the setup instruction, please do so first.</p> Middleware (Recommended)View Utility <p><code>middleware.py</code> <pre><code>import re\nfrom typing import Optional\nfrom doti18n import LocaleData\n\n# Initialize your locales (supports JSON, YAML, XML)\ni18n = LocaleData(\"locales\")\npattern = re.compile(r\"[a-z]{2}\")\n\nclass I18nMiddleware:\n    def __init__(self, get_response):\n        self.get_response = get_response\n\n    def __call__(self, request):\n        accept_language = request.headers.get('Accept-Language')\n        language = self._get_best_match_language(accept_language)\n        request.locale = language\n        request.t = i18n[language]\n        response = self.get_response(request)\n        return response\n\n    @staticmethod\n    def _get_best_match_language(accept_language: Optional[str]) -&gt; str:\n        if not accept_language:\n            return i18n.default_locale\n\n        for match in re.finditer(pattern, accept_language):\n            language_code = match.group()\n            if language_code in i18n.loaded_locales:\n                return language_code\n\n        return i18n.default_locale\n</code></pre></p> <p><code>settings.py</code> <pre><code>MIDDLEWARE = [\n    # ... other middleware ...\n    'path.to.your.middleware.I18nMiddleware',\n]\n</code></pre></p> <p><code>views.py</code> <pre><code>from django.http import JsonResponse\n\ndef main(request):\n    t = request.t.main\n\n    return JsonResponse({\"message\": t.hello})\n</code></pre></p> <pre><code>import re\nfrom django.http import JsonResponse, HttpRequest\nfrom django.urls import path\nfrom doti18n import LocaleData\n\ni18n = LocaleData(\"locales\")\npattern = re.compile(r\"[a-z]{2}\")\n\ndef get_language_code(request: HttpRequest) -&gt; str:\n    \"\"\"\n    Parses the Accept-Language header and returns the best matching locale code.\n    \"\"\"\n    accept_language = request.headers.get(\"Accept-Language\", \"\")\n\n    if not accept_language:\n        return i18n.default_locale\n\n    for match in re.finditer(pattern, accept_language):\n        language_code = match.group()\n        if language_code in i18n.loaded_locales:\n            return language_code\n\n    return i18n.default_locale\n\ndef main(request: HttpRequest):\n    language_code = get_language_code(request)\n    t = i18n[language_code].main\n\n    return JsonResponse({\"message\": t.hello})\n\nurlpatterns = [\n    path('', main),\n]\n</code></pre> <p>Warning</p> <p>Don't use that method of language detection in production as it is quite basic. That's only for demonstration purposes.</p>"},{"location":"integrations/fastapi/","title":"FastAPI","text":"<p>If you don't read the setup instruction, please do so first.</p> DependsMiddleware <pre><code>import re\nfrom typing import Annotated\nfrom fastapi import FastAPI, APIRouter, Depends, Header\nfrom doti18n import LocaleData\n\napp = FastAPI()\nrouter = APIRouter()\ni18n = LocaleData(\"locales\")\npattern = re.compile(r\"[a-z]{2}\")\n\nasync def get_language_code(accept_language: str = Header(alias=\"Accept-Language\")) -&gt; str:\n    if not accept_language:\n        return i18n.default_locale\n\n    for match in re.finditer(pattern, accept_language):\n        language_code = match.group()\n        if language_code in i18n.loaded_locales:\n            return language_code\n\n    return i18n.default_locale\n\n@router.get(\"/\")\nasync def main(language_code: Annotated[str, Depends(get_language_code)]):\n    t = i18n[language_code].main\n\n    return {\"message\": t.hello}\n\napp.include_router(router)\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"localhost\", port=8000)\n</code></pre> <pre><code>import re\nfrom typing import Optional\nfrom fastapi import FastAPI, Request, APIRouter\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom doti18n import LocaleData\n\napp = FastAPI()\ni18n = LocaleData(\"locales\")\nrouter = APIRouter()\npattern = re.compile(r\"[a-z]{2}\")\n\nclass I18nMiddleware(BaseHTTPMiddleware):\n    async def dispatch(self, request: Request, call_next):\n        accept_language = request.headers.get('accept-language')\n        language = self._get_best_match_language(accept_language)\n        request.state.locale = language\n        request.state.translator = i18n[language]\n        response = await call_next(request)\n        return response\n\n    @staticmethod\n    def _get_best_match_language(accept_language: Optional[str]) -&gt; str:\n        if not accept_language:\n            return i18n.default_locale\n\n        for match in re.finditer(pattern, accept_language):\n            language_code = match.group()\n            if language_code in i18n.loaded_locales:\n                return language_code\n\n        return i18n.default_locale\n\n@router.get(\"/\")\nasync def main(request: Request):\n    t = request.state.translator\n\n    return {\"message\": t.hello}\n\n\napp.add_middleware(I18nMiddleware)\napp.include_router(router)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"localhost\", port=8000)\n</code></pre> <p>Warning</p> <p>Don't use that method of language detection in production as it is quite basic. That's only for demonstration purposes.</p>"},{"location":"integrations/flask/","title":"Flask","text":"<p>If you don't read the setup instruction, please do so first.</p> Helper FunctionMiddleware <pre><code>import re\nfrom flask import Flask, request\nfrom doti18n import LocaleData\n\napp = Flask(__name__)\ni18n = LocaleData(\"locales\")\npattern = re.compile(r\"[a-z]{2}\")\n\ndef get_language_code() -&gt; str:\n    accept_language = request.headers.get(\"Accept-Language\")\n\n    if not accept_language:\n        return i18n.default_locale\n\n    for match in re.finditer(pattern, accept_language):\n        language_code = match.group()\n        if language_code in i18n.loaded_locales:\n            return language_code\n\n    return i18n.default_locale\n\n@app.route(\"/\")\ndef main():\n    language_code = get_language_code()\n    t = i18n[language_code].main\n\n    return {\"message\": t.hello}\n\nif __name__ == \"__main__\":\n    app.run(host=\"localhost\", port=8000)\n</code></pre> <pre><code>import re\nfrom typing import Optional\nfrom flask import Flask, request, g\nfrom doti18n import LocaleData\n\napp = Flask(__name__)\ni18n = LocaleData(\"locales\")\npattern = re.compile(r\"[a-z]{2}\")\n\ndef _get_best_match_language(accept_language: Optional[str]) -&gt; str:\n    if not accept_language:\n        return i18n.default_locale\n\n    for match in re.finditer(pattern, accept_language):\n        language_code = match.group()\n        if language_code in i18n.loaded_locales:\n            return language_code\n\n    return i18n.default_locale\n\n@app.before_request\ndef detect_language():\n    accept_language = request.headers.get('Accept-Language')\n    language = _get_best_match_language(accept_language)\n\n    g.locale = language\n    g.t = i18n[language]\n\n@app.route(\"/\")\ndef main():\n    t = g.t.main\n\n    return {\"message\": t.hello}\n\nif __name__ == \"__main__\":\n    app.run(host=\"localhost\", port=8000)\n</code></pre> <p>Warning</p> <p>Don't use that method of language detection in production as it is quite basic. That's only for demonstration purposes.</p>"},{"location":"integrations/setup/","title":"Setup","text":"<p>I expect that you already know how to work with these libraries/frameworks, so this guide will focus on integrating doti18n for localization.</p>"},{"location":"integrations/setup/#project-structure","title":"Project structure","text":"<p>All examples have the following project structure:</p> <pre><code>project_root/\n\u251c\u2500\u2500 locales/\n\u2502   \u251c\u2500\u2500 en.yaml\n\u2502   \u251c\u2500\u2500 fr.yaml\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 main.py\n</code></pre>"},{"location":"integrations/setup/#translation-files","title":"Translation Files","text":"<p>All examples have the following localization file structure:</p> YAMLJSONXML <p><code>locales/en.yaml</code>: <pre><code>main:\n    hello: \"Hello World!\"\n</code></pre> <code>locales/fr.yaml</code>: <pre><code>main:\n    hello: \"Bonjour le monde!\"\n</code></pre></p> <p><code>locales/en.json</code>: <pre><code>{\n    \"main\": {\n        \"hello\": \"Hello World!\"\n    }\n}\n</code></pre> <code>locales/fr.json</code>: <pre><code>{\n    \"main\": {\n        \"hello\": \"Bonjour le monde!\"\n    }\n}\n</code></pre></p> <p><code>locales/en.xml</code>: <pre><code>&lt;locale&gt;\n    &lt;main&gt;\n        &lt;hello&gt;Hello World!&lt;/hello&gt;\n    &lt;/main&gt;\n&lt;/locale&gt;\n</code></pre> <code>locales/fr.xml</code>: <pre><code>&lt;locale&gt;\n    &lt;main&gt;\n        &lt;hello&gt;Bonjour le monde!&lt;/hello&gt;\n    &lt;/main&gt;\n&lt;/locale&gt;\n</code></pre></p> <p>Organization Strategy</p> <p>I highly recommend group related translations by feature or function. This structure improves maintainability as your application grows and allows for convenient nested access via dot-notation: <pre><code>def main(lang: str):\n    t = i18n[lang].main\n    print(t.hello)\n</code></pre></p>"},{"location":"integrations/telegram_api/","title":"Telegram API","text":"<p>If you don't read the setup instruction, please do so first.</p> PyrogramAiogramPython-Telegram-BotTelethon <pre><code>from pyrogram import Client, filters\nfrom pyrogram.types import Message\nfrom doti18n import LocaleData\n\ni18n = LocaleData(\"locales\")\napp = Client(\"bot\", api_id=..., api_hash=\"...\", bot_token=\"...\")\n\n@app.on_message(filters.command(\"start\"))\nasync def main(_, message: Message):\n    t = i18n[message.from_user.language_code].main\n    await message.reply(t.hello)\n\napp.run()\n</code></pre> <pre><code>import asyncio\nfrom aiogram import Bot, Dispatcher\nfrom aiogram.types import Message\nfrom aiogram.filters import CommandStart\nfrom doti18n import LocaleData\n\ni18n = LocaleData(\"locales\")\ndp = Dispatcher()\n\n@dp.message(CommandStart())\nasync def main(message: Message):\n    t = i18n[message.from_user.language_code].main\n    await message.reply(t.hello)\n\nasync def main():\n    bot = Bot(token=\"...\")\n    await dp.start_polling(bot)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <pre><code>from telegram import Update\nfrom telegram.ext import ApplicationBuilder, CommandHandler, ContextTypes\nfrom doti18n import LocaleData\n\ni18n = LocaleData(\"locales\")\n\nasync def main(update: Update, _):\n    t = i18n[update.effective_user.language_code].main\n    await update.message.reply_text(t.hello)\n\napp = ApplicationBuilder().token(\"...\").build()\napp.add_handler(CommandHandler(\"start\", hello))\napp.run_polling()\n</code></pre> <pre><code>from telethon import TelegramClient, events\nfrom doti18n import LocaleData\n\ni18n = LocaleData(\"locales\")\nclient = TelegramClient(\"bot\", api_id=..., api_hash=\"...\").start(bot_token=\"...\")\n\n@client.on(events.NewMessage(pattern='/start'))\nasync def main(event: events.NewMessage.Event):\n    user = await event.get_sender()\n    t = i18n[user.lang_code].main\n    await event.reply(t.hello)\n\nclient.run_until_disconnected()\n</code></pre>"},{"location":"usage/configuration/","title":"Configuration","text":""},{"location":"usage/configuration/#strict-non-strict-mode","title":"Strict / Non-Strict Mode","text":"<p>doti18n operates in two modes to accommodate different stages of development and production requirements.</p> <ul> <li>Strict Mode: Raises an exception when accessing a non-existent key or path. This is recommended for development and testing to ensure all translations are present.</li> <li>Non-Strict Mode (Default): Returns a special <code>NoneWrapper</code> object instead of raising an exception. This prevents application crashes by behaving like <code>None</code>, while logging a warning to notify developers of the missing translation.</li> </ul> <p>NoneWrapper Behavior</p> <p><code>NoneWrapper</code> behaves like <code>None</code>, but is not <code>None</code>. To check for missing values explicitly, use: <code>value == None</code>, or check for truthiness: <code>if not value:</code></p>"},{"location":"usage/configuration/#usage-example","title":"Usage Example","text":"Strict ModeNon-Strict Mode <pre><code>from doti18n import LocaleData\n\n# Initialize in strict mode\ni18n = LocaleData(\"locales\", strict=True)\n\ntry:\n    print(i18n[\"en\"].non_existent_key)  # Raises KeyError\nexcept KeyError as e:\n    print(f\"Error: {e}\") \n    # Output: key/index path 'non_existent_key' not found...\n</code></pre> <pre><code>import logging\nfrom doti18n import LocaleData\n\n# Configure logging to capture warnings\nlogging.basicConfig(level=logging.WARNING)\n\n# Initialize in non-strict mode (default)\ni18n = LocaleData(\"locales\", strict=False)\n\ntranslation = i18n[\"en\"].non_existent_key\n\nprint(translation)  # Output: None\n# Log: WARNING:LocaleTranslator['en']: key/index path 'non_existent_key' not found...\n</code></pre>"},{"location":"usage/configuration/#preloading-manual-loading","title":"Preloading &amp; Manual Loading","text":"<p>doti18n supports preloading to optimize performance.  When enabled, all locale files in the specified directory are loaded into memory upon initialization.</p> <p>Preloading is enabled by default.</p> <p>Warning</p> <p><code>preload=True</code> is the only way to load multilocale files.  Attempting to load multilocale configurations via <code>get_locale()</code> will result in an error.</p>"},{"location":"usage/configuration/#disabling-preload","title":"Disabling Preload","text":"<p>To disable preloading, set <code>preload=False</code> during initialization.  You must then load locales manually using the <code>get_locale()</code> method.</p>"},{"location":"usage/configuration/#manual-loading-example","title":"Manual Loading Example","text":"<p>Ensure your <code>locales</code> directory contains valid translation files (e.g., <code>en.yaml</code>, <code>en.json</code>, <code>en.xml</code>).</p> <p>1. Define Locale Files</p> YAMLJSONXML <p><code>locales/en.yaml</code>: <pre><code>hello: \"Hello World!\"\n</code></pre></p> <p><code>locales/en.json</code>: <pre><code>{\"hello\": \"Hello World!\"}\n</code></pre></p> <p><code>locales/en.xml</code>: <pre><code>&lt;locale&gt;\n    &lt;hello&gt;Hello World!&lt;/hello&gt;\n&lt;/locale&gt;\n</code></pre></p> <p>2. Load and Access</p> <pre><code>from doti18n import LocaleData\n\n# 1. Initialize without preloading\ni18n = LocaleData(\"locales\", preload=False)\n\n# 2. Manually load a specific locale\nt = i18n.get_locale(\"en\")\n\n# 3. Access translations\nprint(t.hello)  # Output: Hello World!\n</code></pre> <p>Note</p> <p>When using <code>get_locale()</code> method, you don't need to specify file extensions.  doti18n automatically detects and loads the appropriate file if it exists and is not loaded yet.</p>"},{"location":"usage/custom_loaders/","title":"Custom Loaders","text":"<p>You can extend doti18n to support custom file formats by implementing a custom loader. Loaders are automatically registered upon class definition.</p>"},{"location":"usage/custom_loaders/#requirements","title":"Requirements","text":"<p>To create a loader, define a class that inherits from <code>doti18n.loaders.BaseLoader</code> and meets these criteria:</p> <ol> <li><code>file_extension</code>: A string attribute defining the extension (e.g., <code>.custom</code>).</li> <li><code>__init__</code>: Must accept a <code>strict: bool</code> argument.</li> <li><code>load</code> method: Must read the file and return data in one of these formats:<ul> <li>Single locale: <code>{ \"en\": { ... } }</code> (derived from filename).</li> <li>Multilocale: <code>[ {...}, {...} ]</code>. (with key <code>locale</code> inside each dict).</li> </ul> </li> </ol> <p>Execution order</p> <p>You must define or import your custom loader before creating the <code>LocaleData</code> instance.</p> <p>Why? The Main Loader(doti18n.loaders.Loader) register all available loaders at initialization. If your custom loader is defined later, it won't be registered and won't be used.</p>"},{"location":"usage/custom_loaders/#example-implementation","title":"Example Implementation","text":"<pre><code>import os\nfrom typing import Union, Optional, Dict, List\nfrom pathlib import Path\n\nfrom doti18n.loaders import BaseLoader\n# import custom_parser \n\nclass CustomLoader(BaseLoader):\n    file_extension = \".custom\"\n\n    def __init__(self, strict: bool = False):\n        self._strict = strict\n\n    def load(self, filepath: Union[str, Path]) -&gt; Optional[Union[Dict, List[dict]]]:\n        # 1. Read file content\n        with open(filepath, encoding='utf-8') as file:\n            content = file.read()\n\n        # 2. Parse data (using your custom logic)\n        # data = custom_parser.parse(content)\n        data = {\"mock_key\": \"mock_value\"} \n\n        # 3. Determine locale (usually from filename)\n        locale = os.path.splitext(os.path.basename(filepath))[0]\n\n        # 4. Return strictly typed dict: {locale: data}\n        return {locale: data}\n</code></pre>"},{"location":"usage/formatting/","title":"Formatting","text":"<p>doti18n supports three formatting styles out of the box.  You can even mix them in a single string (though consistency is highly recommended).</p>"},{"location":"usage/formatting/#supported-syntax","title":"Supported Syntax","text":"<p>1. Python-style (Curly braces <code>{}</code>)</p> <ul> <li><code>\"Hello, {}!\"</code> (positional)</li> <li><code>\"Hello, {name}!\"</code> (named)</li> <li><code>\"Balance: {count:.2f}\"</code> (with format spec)</li> </ul> <p>2. Shell-style (Dollar sign <code>$</code>)</p> <ul> <li><code>\"Hello, $name!\"</code></li> <li><code>\"Hello, ${name}!\"</code></li> <li><code>\"Hello, $1!\"</code> (positional/indexed)</li> </ul> <p>3. C-style (Percent sign <code>%</code>)</p> <ul> <li><code>\"Hello, %s!\"</code> (positional)</li> <li><code>\"Hello, %(name)s!\"</code> (named)</li> </ul>"},{"location":"usage/formatting/#escaping","title":"Escaping","text":"<p>To use literal characters that are reserved for formatting, double them:</p> <ul> <li><code>{{</code> and <code>}}</code> \u2192 <code>{</code> and <code>}</code></li> <li><code>$$</code> \u2192 <code>$</code></li> <li><code>%%</code> \u2192 <code>%</code></li> </ul> <p>Note</p> <p>Escaping is only processed when the string is called as a function. If accessed as a raw attribute, the string is returned \"as-is\" (with double characters intact).</p>"},{"location":"usage/formatting/#usage-example","title":"Usage Example","text":"<p><code>locales/en.yaml</code>: <pre><code>balance_python: \"Your balance is {amount:.2f} dollars.\"\ngreeting_c: \"Hello, %(name)s!\"\nfarewell_shell: \"Goodbye, $name!\"\nescaped_str: \"Literal braces: {{ and }}.\"\n</code></pre></p> <p>Python Code:</p> <pre><code>from doti18n import LocaleData\n\ni18n = LocaleData(\"locales\")\n\n# 1. Standard Formatting\nprint(i18n[\"en\"].balance_python(amount=1234.543))   # Output: Your balance is 1234.54 dollars.\nprint(i18n[\"en\"].greeting_c(name=\"Alice\"))          # Output: Hello, Alice!\nprint(i18n[\"en\"].farewell_shell(name=\"Bob\"))        # Output: Goodbye, Bob!\n\n# 2. Escaped Characters\nprint(i18n[\"en\"].escaped_str())                     # Output: Literal braces: { and }.\n</code></pre>"},{"location":"usage/formatting/#missing-variables-graceful-degradation","title":"Missing Variables (Graceful Degradation)","text":"<p>If you omit required variables, doti18n does not crash. Instead, it removes the unresolved placeholders from the string.</p> <pre><code>print(i18n[\"en\"].balance_python())  # Output: Your balance is dollars.\nprint(i18n[\"en\"].greeting_c())      # Output: Hello, !\n</code></pre> <p>Type Safety</p> <p>Accessing a key without parentheses (e.g., <code>i18n[\"en\"].hello</code>) returns the raw string. Calling it (e.g., <code>i18n[\"en\"].hello()</code>) triggers formatting.</p> <p>To catch forgotten calls or invalid arguments at development time, generate type stubs using the CLI.</p>"},{"location":"usage/icumf/","title":"ICU Message Format","text":"<p>ICU Message Format (ICUMF) is powered by its own parser and formatter within doti18n. For pluralization, it follows CLDR Plural Rules, which are powered by Babel.</p>"},{"location":"usage/icumf/#syntax","title":"Syntax","text":"<p>ICUMF uses a specific syntax for defining messages, including pluralization, selection, and variable interpolation.</p> <ul> <li>Variable Interpolation: <code>{variable}</code></li> <li>Hash: In sub-numeric formatters (<code>plural</code>, <code>selectordinal</code>), <code>#</code> represents the <code>count</code> value.</li> <li>Pluralization: <code>{variable, plural, one {singular form} other {plural form}}</code></li> <li>Selectordinal: <code>{variable, selectordinal, one {1st form} two {2nd form} few {3rd form} other {default form}}</code></li> <li>Select: <code>{variable, select, option1 {text1} option2 {text2} other {default text}}</code></li> <li>Formatters: <code>{variable, formatter, style}</code> (e.g., for dates).</li> <li>Escaping: Use single quotes <code>'</code> to escape the next character. To include a literal single quote, use two single quotes <code>''</code>.</li> <li>Nesting: ICUMF supports nested constructs for complex messages.</li> <li>Whitespace: Ignored outside of the message text.</li> </ul>"},{"location":"usage/icumf/#basic-example","title":"Basic Example","text":"YAMLJSONXML <p><code>locales/en.yaml</code>: <pre><code>cat: \"I have {count, plural, one {# cat} other {# cats}}\"\n</code></pre></p> <p><code>locales/en.json</code>: <pre><code>{\n    \"cat\": \"I have {count, plural, one {# cat} other {# cats}}\"\n}\n</code></pre></p> <p><code>locales/en.xml</code>: <pre><code>&lt;locale&gt;\n    &lt;cat&gt;I have {count, plural, one {# cat} other {# cats}}&lt;/cat&gt;\n&lt;/locale&gt;\n</code></pre></p> <p>Usage:</p> <pre><code>from doti18n import LocaleData\n\ni18n = LocaleData(\"locales\")\n\nprint(i18n[\"en\"].cat(count=1))   # Output: I have 1 cat\nprint(i18n[\"en\"].cat(count=3))   # Output: I have 3 cats\nprint(i18n[\"en\"].cat(count=11))  # Output: I have 11 cats\n</code></pre>"},{"location":"usage/icumf/#manage-icumf","title":"Manage ICUMF","text":"<p>By default, doti18n automatically enables ICUMF parsing with standard settings. However, you can customize its behavior, adjust performance settings, or disable it entirely.</p> <p>To do this, you need to manually configure the <code>Loader</code> and inject it into <code>LocaleData</code>.</p>"},{"location":"usage/icumf/#disabling-icumf","title":"Disabling ICUMF","text":"<p>If you don't use ICUMF features and want to avoid the parsing overhead, or if your strings contain characters that conflict with ICUMF syntax (like <code>{}</code> used for other purposes), you can disable it.</p> <pre><code>from doti18n import LocaleData\nfrom doti18n.loaders import Loader\n\n# 1. Create a loader with ICUMF disabled\nloader = Loader(icumf=False)\n\n# 2. Inject the loader into LocaleData\ni18n = LocaleData(\"locales\", loader=loader)\n</code></pre>"},{"location":"usage/icumf/#forcing-icumf","title":"Forcing ICUMF","text":"<p>If for some reason ICUMF doesn't parse your strings automatically (e.g., due to conflicts with other formatting styles), you can force-enable it via marking strings in your localization files. This <code>icu:</code> prefix tells doti18n to always treat the string as ICUMF. doti18n will delete the prefix before parsing.</p> YAMLJSONXML <p><code>locales/en.yaml</code>: <pre><code>cat: \"icu:I have {count, plural, one {# cat} other {# cats}}\"\n</code></pre></p> <p><code>locales/en.json</code>: <pre><code>{\n    \"cat\": \"icu:I have {count, plural, one {# cat} other {# cats}}\"\n}\n</code></pre></p> <p><code>locales/en.xml</code>: <pre><code>&lt;locale&gt;\n    &lt;cat&gt;icu:I have {count, plural, one {# cat} other {# cats}}&lt;/cat&gt;\n&lt;/locale&gt;\n</code></pre></p>"},{"location":"usage/icumf/#advanced-configuration","title":"Advanced Configuration","text":"<p>To adjust the cache size or parser behavior, you need to create an <code>ICUMF</code> instance manually and pass it to the loader.</p> <pre><code>from doti18n import LocaleData\nfrom doti18n.loaders import Loader\nfrom doti18n.icumf import ICUMF\n\n# 1. Configure ICUMF\nicumf = ICUMF(\n    cache_size=2048,      # Increase cache for rendered strings\n    strict=True,          # Enforce strict validation\n\n    # Parser options (passed via kwargs)\n    depth_limit=20,       # Limit nesting depth\n    allow_tags=False,     # Disable HTML-like tag parsing\n    require_other=False   # Don't require 'other' in plural/selectordinal (not recommended, it may break doti18n logic)\n)\n\n# 2. Create Loader with custom ICUMF\nloader = Loader(icumf=icumf)\n\n# 3. Initialize LocaleData\ni18n = LocaleData(\"locales\", loader=loader)\n</code></pre>"},{"location":"usage/icumf/#parser-parameters","title":"Parser Parameters","text":"<p>These parameters are passed as keyword arguments (<code>**kwargs</code>) to the <code>ICUMF</code> constructor and control the internal <code>Parser</code>.</p> Parameter Type Default Description <code>cache_size</code> <code>int</code> <code>1024</code> The maximum number of rendered strings to keep in memory (LRU Cache). <code>depth_limit</code> <code>int</code> <code>50</code> Maximum recursion depth for nested messages. Prevents stack overflow on malformed strings. <code>allow_tags</code> <code>bool</code> <code>True</code> Enables parsing of HTML/XML-like tags (e.g., <code>&lt;b&gt;Bold&lt;/b&gt;</code>). <code>strict_tags</code> <code>bool</code> <code>True</code> If <code>True</code>, ensures that closing tags match opening tags (e.g., <code>&lt;b&gt;...&lt;/i&gt;</code> raises an error). <code>tag_prefix</code> <code>str</code> <code>None</code> If set, only tags starting with this prefix are parsed. <code>require_other</code> <code>bool</code> <code>True</code> If <code>True</code>, requires an <code>other</code> option in <code>plural</code>, <code>select</code>, and <code>selectordinal</code> formats. <code>allow_format_spaces</code> <code>bool</code> <code>True</code> Allows whitespace inside format arguments (e.g., <code>{ count, plural, ... }</code>)."},{"location":"usage/icumf/#variable-interpolation","title":"Variable Interpolation","text":"<p>If you want to include additional variables in your messages, simply add them to the message string and pass them as keyword arguments.</p> YAMLJSONXML <p><code>locales/en.yaml</code>: <pre><code>greeting: \"Hello, {name}! You have {count, plural, one {# new message} other {# new messages}}.\"\n</code></pre></p> <p><code>locales/en.json</code>: <pre><code>{\n    \"greeting\": \"Hello, {name}! You have {count, plural, one {# new message} other {# new messages}}.\"\n}\n</code></pre></p> <p><code>locales/en.xml</code>: <pre><code>&lt;locale&gt;\n    &lt;greeting&gt;Hello, {name}! You have {count, plural, one {# new message} other {# new messages}}.&lt;/greeting&gt;\n&lt;/locale&gt;\n</code></pre></p> <p>Usage:</p> <pre><code>from doti18n import LocaleData\n\ni18n = LocaleData(\"locales\")\n\nprint(i18n[\"en\"].greeting(name=\"Alice\", count=1))   # Output: Hello, Alice! You have 1 new message.\nprint(i18n[\"en\"].greeting(name=\"Bob\", count=5))     # Output: Hello, Bob! You have 5 new messages.\n</code></pre> <p>Note</p> <p>If your ICUMF string contains only variable interpolation (without pluralization or formatters), it won't be processed as ICUMF.  Instead, it will use standard Python formatting (<code>str.format()</code>).</p>"},{"location":"usage/icumf/#pluralization-and-selectordinal","title":"Pluralization and Selectordinal","text":"<p>ICUMF supports pluralization using the <code>plural</code> and <code>selectordinal</code> formats. You can define different message forms based on the numeric value of a variable.</p> YAMLJSONXML <p><code>locales/en.yaml</code>: <pre><code>item_count: \"You have {count, plural, one {# item} other {# items}} in your cart.\"\nrank: \"You are ranked {position, selectordinal, one {#st} two {#nd} few {#rd} other {#th}} in the competition.\"\n</code></pre></p> <p><code>locales/en.json</code>: <pre><code>{\n    \"item_count\": \"You have {count, plural, one {# item} other {# items}} in your cart.\",\n    \"rank\": \"You are ranked {position, selectordinal, one {#st} two {#nd} few {#rd} other {#th}} in the competition.\"\n}\n</code></pre></p> <p><code>locales/en.xml</code>: <pre><code>&lt;locale&gt;\n    &lt;item_count&gt;You have {count, plural, one {# item} other {# items}} in your cart.&lt;/item_count&gt;\n    &lt;rank&gt;You are ranked {position, selectordinal, one {#st} two {#nd} few {#rd} other {#th}} in the competition.&lt;/rank&gt;\n&lt;/locale&gt;\n</code></pre></p> <p>Usage:</p> <pre><code>from doti18n import LocaleData\n\ni18n = LocaleData(\"locales\")\n\nprint(i18n[\"en\"].item_count(count=1))    # Output: You have 1 item in your cart.\nprint(i18n[\"en\"].item_count(count=4))    # Output: You have 4 items in your cart.\n\nprint(i18n[\"en\"].rank(position=1))       # Output: You are ranked 1st in the competition.\nprint(i18n[\"en\"].rank(position=2))       # Output: You are ranked 2nd in the competition.\nprint(i18n[\"en\"].rank(position=3))       # Output: You are ranked 3rd in the competition.\nprint(i18n[\"en\"].rank(position=4))       # Output: You are ranked 4th in the competition.\n</code></pre>"},{"location":"usage/icumf/#select","title":"Select","text":"<p>The <code>select</code> format allows you to define different message forms based on exact string matches (similar to a switch-case statement).</p> YAMLJSONXML <p><code>locales/en.yaml</code>: <pre><code>user_status: \"{status, select, active {Welcome back!} inactive {Please activate your account.} banned {Your account is banned.} other {Hello, guest!}}\"\ngender_greeting: \"{gender, select, male {Hello, sir!} female {Hello, miss!} other {Hello!}}\"\n</code></pre></p> <p><code>locales/en.json</code>: <pre><code>{\n    \"user_status\": \"{status, select, active {Welcome back!} inactive {Please activate your account.} banned {Your account is banned.} other {Hello, guest!}}\",\n    \"gender_greeting\": \"{gender, select, male {Hello, sir!} female {Hello, miss!} other {Hello!}}\"\n}\n</code></pre></p> <p><code>locales/en.xml</code>: <pre><code>&lt;locale&gt;\n    &lt;user_status&gt;{status, select, active {Welcome back!} inactive {Please activate your account.} banned {Your account is banned.} other {Hello, guest!}}&lt;/user_status&gt;\n    &lt;gender_greeting&gt;{gender, select, male {Hello, sir!} female {Hello, miss!} other {Hello!}}&lt;/gender_greeting&gt;\n&lt;/locale&gt;\n</code></pre></p> <p>Usage:</p> <pre><code>from doti18n import LocaleData\n\ni18n = LocaleData(\"locales\")\n\nprint(i18n[\"en\"].user_status(status=\"active\"))    # Output: Welcome back!\nprint(i18n[\"en\"].user_status(status=\"inactive\"))  # Output: Please activate your account.\nprint(i18n[\"en\"].user_status(status=\"banned\"))    # Output: Your account is banned.\nprint(i18n[\"en\"].user_status(status=\"other\"))     # Output: Hello, guest!\n\nprint(i18n[\"en\"].gender_greeting(gender=\"male\"))    # Output: Hello, sir!\nprint(i18n[\"en\"].gender_greeting(gender=\"female\"))  # Output: Hello, miss!\nprint(i18n[\"en\"].gender_greeting(gender=\"other\"))   # Output: Hello!\n</code></pre>"},{"location":"usage/icumf/#formatters","title":"Formatters","text":"<p>Out of the box, doti18n supports the <code>date</code> formatter. You can also implement custom formatters by extending the <code>BaseFormatter</code> class. See the Custom Formatters section for details.</p> YAMLJSONXML <p><code>locales/en.yaml</code>: <pre><code>appointment: \"Your appointment is on {date, date, short}.\"\nnow: \"Current date and time: {now, date, long}.\"\ncustom: \"Custom formatted date: {date, date, %A, %d %B %Y year, %H:%M:%S (%Z)}.\"\n</code></pre></p> <p><code>locales/en.json</code>: <pre><code>{\n    \"appointment\": \"Your appointment is on {date, date, short}.\",\n    \"now\": \"Current date and time: {now, date, long}.\",\n    \"custom\": \"Custom formatted date: {date, date, %A, %d %B %Y year, %H:%M:%S (%Z)}.\"\n}\n</code></pre></p> <p><code>locales/en.xml</code>: <pre><code>&lt;locale&gt;\n    &lt;appointment&gt;Your appointment is on {date, date, short}.&lt;/appointment&gt;\n    &lt;now&gt;Current date and time: {now, date, long}.&lt;/now&gt;\n    &lt;custom&gt;Custom formatted date: {date, date, %A, %d %B %Y year, %H:%M:%S (%Z)}.&lt;/custom&gt;\n&lt;/locale&gt;\n</code></pre></p> <p>Usage:</p> <pre><code>from doti18n import LocaleData\nfrom datetime import datetime\nfrom zoneinfo import ZoneInfo\n\ni18n = LocaleData(\"locales\")\nnow = datetime.now(tz=ZoneInfo(\"UTC\"))\n\nprint(i18n[\"en\"].appointment(date=now))  # Output: Your appointment is on 29.01.2026.\nprint(i18n[\"en\"].now(now=now))           # Output: Current date and time: 29.01.2026 22:30:19.\nprint(i18n[\"en\"].custom(date=now))       # Output: Custom formatted date: Thursday, 29 January 2026 year, 22:30:19 (UTC).\n</code></pre>"},{"location":"usage/icumf/#escaping","title":"Escaping","text":"<p>To include literal characters that are reserved for ICUMF formatting (like <code>{</code> or <code>}</code>), use single quotes <code>'</code> to escape the sequence. To include a single quote itself, use two single quotes <code>''</code>.</p> YAMLJSONXML <p><code>locales/en.yaml</code>: <pre><code>escaped: \"This is a literal brace: '{' and this is a single quote: ''.\"\n</code></pre></p> <p><code>locales/en.json</code>: <pre><code>{\n    \"escaped\": \"This is a literal brace: '{' and this is a single quote: ''.\"\n}\n</code></pre></p> <p><code>locales/en.xml</code>: <pre><code>&lt;locale&gt;\n    &lt;escaped&gt;This is a literal brace: '{' and this is a single quote: ''.&lt;/escaped&gt;\n&lt;/locale&gt;\n</code></pre></p> <p>Usage:</p> <pre><code>from doti18n import LocaleData\n\ni18n = LocaleData(\"locales\")\n\nprint(i18n[\"en\"].escaped())  # Output: This is a literal brace: { and this is a single quote: '.\n</code></pre>"},{"location":"usage/icumf/#nesting","title":"Nesting","text":"<p>ICUMF supports nesting constructs to build complex logic. You can place pluralization, select, and other formats inside each other.</p> YAMLJSONXML <p><code>locales/en.yaml</code>: <pre><code>backpack: |\n    You have {item, select,\n        book {{count, plural, one {# book} other {# books}}} \n        pen {{count, plural, one {# pen} other {# pens}}} \n        other {{count} items}\n    } in your backpack.\n</code></pre></p> <p><code>locales/en.json</code>: <pre><code>{\n    \"backpack\": \"You have {item, select, book {{count, plural, one {# book} other {# books}}} pen {{count, plural, one {# pen} other {# pens}}} other {{count} items}} in your backpack.\"\n}\n</code></pre></p> <p><code>locales/en.xml</code>: <pre><code>&lt;locale&gt;\n    &lt;backpack&gt;You have {item, select, \n                  book {{count, plural, one {# book} other {# books}}} \n                  pen {{count, plural, one {# pen} other {# pens}}} \n                  other {{count} items}\n                  } in your backpack.\n    &lt;/backpack&gt;\n&lt;/locale&gt;\n</code></pre></p> <p>Important: Variable Context</p> <p>Notice the <code>other</code> option in the example above. Inside <code>other</code>, we use <code>{count}</code> instead of <code>#</code>.</p> <p>The hash symbol (<code>#</code>) represents the count only within sub-numeric formatters (like <code>plural</code> or <code>selectordinal</code>). Since <code>select</code> is not numeric, you must use the standard <code>{count}</code> interpolation variable there.</p> <p>Usage:</p> <pre><code>from doti18n import LocaleData\n\ni18n = LocaleData(\"locales\")\n\nprint(i18n[\"en\"].backpack(item=\"book\", count=1))    # Output: You have 1 book in your backpack.\nprint(i18n[\"en\"].backpack(item=\"book\", count=3))    # Output: You have 3 books in your backpack.\nprint(i18n[\"en\"].backpack(item=\"pen\", count=1))     # Output: You have 1 pen in your backpack.\nprint(i18n[\"en\"].backpack(item=\"pen\", count=5))     # Output: You have 5 pens in your backpack.\n\n# This uses the 'other' case.\nprint(i18n[\"en\"].backpack(item=\"sword\", count=10))  # Output: You have 10 items in your backpack.\n</code></pre>"},{"location":"usage/icumf/#whitespaces","title":"Whitespaces","text":"<p>ICUMF ignores whitespace characters (spaces, tabs, newlines) outside of the message text. You can format your ICUMF strings for better readability without affecting the logic.</p> <p>However, be careful when using multi-line strings in YAML or XML, as indentation inside the message string itself (e.g., inside <code>{...}</code>) might be preserved depending on how the file is parsed.</p> YAMLJSONXML <p><code>locales/en.yaml</code>: <pre><code>cart: \"You have {count, plural, one {  # item  } other {  # items  }} in your cart.\"\n</code></pre></p> <p><code>locales/en.json</code>: <pre><code>{\n    \"cart\": \"You have {count, plural, one {  # item  } other {  # items  }} in your cart.\"\n}\n</code></pre></p> <p><code>locales/en.xml</code>: <pre><code>&lt;locale&gt;\n    &lt;cart&gt;You have {count, plural, one {  # item  } other {  # items  }} in your cart.&lt;/cart&gt;\n&lt;/locale&gt;\n</code></pre></p> <p>Usage:</p> <pre><code>from doti18n import LocaleData\n\ni18n = LocaleData(\"locales\")\n\nprint(i18n[\"en\"].cart(count=1))   # Output: You have   1 item   in your cart.\nprint(i18n[\"en\"].cart(count=4))   # Output: You have   4 items   in your cart.\n</code></pre> <p>As seen above, the extra spaces explicitly placed inside the plural forms (<code>{  # item  }</code>) are preserved in the output.</p>"},{"location":"usage/icumf/#custom-formatters","title":"Custom Formatters","text":""},{"location":"usage/icumf/#requirements","title":"Requirements","text":"<p>To create a custom formatter, define a class that inherits from <code>doti18n.icumf.formatter.BaseFormatter</code> and meets these criteria:</p> <ol> <li><code>name</code>: A string representing the formatter's name (e.g., <code>\"crypto\"</code>).</li> <li><code>is_subnumeric</code>: Boolean. True if the formatter logic depends on a numeric count (like <code>plural</code>).</li> <li><code>is_submessage</code>: Boolean. True if the formatter contains nested messages (like <code>select</code>).</li> <li><code>__init__</code>: Must accept a <code>strict: bool</code> argument.</li> <li><code>__call__</code>: Must implement the formatting logic and accept/return parameters as defined in the parent class.</li> </ol>"},{"location":"usage/icumf/#example-implementation","title":"Example Implementation","text":"<p>Tip</p> <p>If you are unsure how to implement a sub-numeric or sub-message formatter, refer to the source code of built-in formatters in the <code>doti18n.icumf.formatters</code> module.</p> YAMLJSONXML <p><code>locales/en.yaml</code>: <pre><code>crypto: \"You have {value, crypto, usdt} in your wallet.\"\n</code></pre></p> <p><code>locales/en.json</code>: <pre><code>{\n    \"crypto\": \"You have {value, crypto, usdt} in your wallet.\"\n}\n</code></pre></p> <p><code>locales/en.xml</code>: <pre><code>&lt;locale&gt;\n    &lt;crypto&gt;You have {value, crypto, usdt} in your wallet.&lt;/crypto&gt;\n&lt;/locale&gt;\n</code></pre></p> <pre><code>from doti18n import LocaleData\nfrom doti18n.icumf.formatters import BaseFormatter\nfrom doti18n.icumf.nodes import Node, FormatNode, TextNode\nfrom typing import Sequence, Optional\n# import some_external_crypto_library as clib\n\nclass CryptoFormatter(BaseFormatter):\n    name = \"crypto\"\n    is_subnumeric = False\n    is_submessage = False\n\n    def __init__(self, strict: bool = False):\n        self._strict = strict\n\n    def __call__(self, t: \"LocaleTranslator\", node: Node, **kwargs) -&gt; Sequence[Optional[Node]]:\n        if not isinstance(node, FormatNode):\n            raise TypeError(\"CryptoFormatter can only process FormatNode instances.\")\n\n        value = kwargs.get(node.name)\n        if value is None:\n            if self._strict:\n                raise ValueError(f\"Missing value for '{node.name}' in CryptoFormatter.\")\n            else:\n                return []  # Return empty for graceful degradation\n\n        # Assume clib.format converts coins to the style (e.g., USDT)\n        # formatted_value = clib.format(value, node.style)\n        formatted_value = \"84467,51\" # Mock result\n\n        return [TextNode(f\"{formatted_value} {node.style.upper()}\")]\n\n# Register formatter (by defining/importing it) BEFORE LocaleData initialization\ni18n = LocaleData(\"locales\")\n\nprint(i18n[\"en\"].crypto(value=\"123 BTC\"))  # Output: You have 84467,51 USDT in your wallet.\n</code></pre> <p>Execution Order</p> <p>You must define or import your custom formatter before creating the <code>LocaleData</code> or <code>Loader</code> instance.</p> <p>Why? The ICUMF manager registers all available formatters at initialization. If your custom formatter is defined later, it won't be registered.</p>"},{"location":"usage/icumf/#tags-html-support","title":"Tags &amp; HTML Support","text":"<p>doti18n's parser supports XML/HTML-like tags out of the box. By default, they are rendered \"as is\" (useful for web apps), but you can intercept and transform them \u2014 for example, to convert HTML tags into Markdown for Telegram bots or console output. You also can implent your own tag formatter (see custom formatters) to handle custom tags or give it in another format.</p>"},{"location":"usage/icumf/#basic-usage","title":"Basic Usage","text":"<p>Tags are parsed as structured nodes, not just text. This ensures that opening and closing tags match (unless <code>strict_tags=False</code>).</p> YAMLJSONXML <p><code>locales/en.yaml</code>: <pre><code>welcome: \"Welcome, &lt;b&gt;{name}&lt;/b&gt;! Click &lt;link&gt;here&lt;/link&gt;.\"\n</code></pre></p> <p><code>locales/en.json</code>: <pre><code>{\n    \"welcome\": \"Welcome, &lt;b&gt;{name}&lt;/b&gt;! Click &lt;link&gt;here&lt;/link&gt;.\"\n}\n</code></pre></p> <p><code>locales/en.xml</code>: <pre><code>&lt;locale&gt;\n    &lt;welcome&gt;Welcome, &lt;b&gt;{name}&lt;/b&gt;! Click &lt;link&gt;here&lt;/link&gt;.&lt;/welcome&gt;\n&lt;/locale&gt;\n</code></pre></p> <p>Usage (Default HTML behavior): <pre><code>print(i18n[\"en\"].welcome(name=\"User\"))\n# Output: Welcome, &lt;b&gt;User&lt;/b&gt;! Click &lt;link&gt;here&lt;/link&gt;.\n</code></pre></p> <p>Note</p> <p>The ICUMF parser does not support self-closing tags (like <code>&lt;br/&gt;</code>) or tags with attributes (like <code>&lt;a href=\"...\"&gt;</code>). Such tags are returned as-is, and a warning is logged if <code>strict_tags=True</code>.</p> <p>By default, <code>doti18n</code> converts <code>&lt;link&gt;</code> tags into HTML <code>&lt;a&gt;</code> tags with <code>href</code> attributes. You can customize this behavior by implementing a custom tag formatter (see below).</p> <p>If you need to include unsupported tags, consider escaping them with single quotes (<code>'&lt;br/'&gt;</code>, <code>'&lt;a href=\"...\"'&gt;</code>) or using placeholders instead (e.g., <code>{line_break}</code>) and passing the values as arguments.</p>"},{"location":"usage/icumf/#custom-tag-processing-html-to-markdown","title":"Custom Tag Processing (HTML to Markdown)","text":"<p>To transform tags, you need to implement a custom formatter (or use built-in) class and inject it into the <code>ICUMF</code> configuration via the <code>tag_formatter</code> argument.</p> <p>The formatter receives a <code>TagNode</code> which contains <code>children</code> (the content inside the tag).</p> <p>Example: Converting <code>&lt;b&gt;</code> to <code>**</code> and <code>&lt;i&gt;</code> to <code>__</code></p> YAMLJSONXML <p><code>locales/en.yaml</code>: <pre><code>msg: \"Hello &lt;b&gt;{name}&lt;/b&gt;, this is &lt;i&gt;italic&lt;/i&gt;.\"\n</code></pre></p> <p><code>locales/en.json</code>: <pre><code>{\n    \"msg\": \"Hello &lt;b&gt;{name}&lt;/b&gt;, this is &lt;i&gt;italic&lt;/i&gt;.\"\n}\n</code></pre></p> <p><code>locales/en.xml</code>: <pre><code>&lt;locale&gt;\n    &lt;msg&gt;Hello &lt;b&gt;{name}&lt;/b&gt;, this is &lt;i&gt;italic&lt;/i&gt;.&lt;/msg&gt;\n&lt;/locale&gt;\n</code></pre></p> <pre><code>from doti18n import LocaleData\nfrom doti18n.loaders import Loader\nfrom doti18n.icumf import ICUMF\nfrom doti18n.icumf.formatters import MarkdownFormatter\n\n# Initialize ICUMF with the custom tag formatter\nicumf = ICUMF(tag_formatter=MarkdownFormatter)\nloader = Loader(icumf=icumf)\ni18n = LocaleData(\"locales\", loader=loader)\n\nprint(i18n[\"en\"].msg(name=\"Alice\"))  # Output: Hello **Alice**, this is __italic__.\n</code></pre> <p>Nested Tags</p> <p>Since the formatter returns the original <code>node.children</code>, doti18n continues to process the content inside the tag. This means nesting (e.g., <code>&lt;b&gt;&lt;i&gt;Text&lt;/i&gt;&lt;/b&gt;</code>) works automatically with your custom formatter.</p>"},{"location":"usage/pluralization/","title":"Pluralization","text":"<p>Pluralization is powered by Babel and follows CLDR Plural Rules.</p> <p>To use it:</p> <ol> <li>Define the required forms (e.g., <code>one</code>, <code>few</code>, <code>many</code>, <code>other</code>) in your localization file.  </li> <li>Call the key as a function in Python, passing <code>count</code> as the first positional argument.</li> </ol> <p>doti18n automatically selects the correct form based on the locale and the count.</p>"},{"location":"usage/pluralization/#basic-example","title":"Basic Example","text":"YAMLJSONXML <p><code>locales/en.yaml</code>: <pre><code>cat:\n    one: \"{count} cat\"\n    other: \"{count} cats\"\n</code></pre></p> <p><code>locales/en.json</code>: <pre><code>{\n    \"cat\": {\n        \"one\": \"{count} cat\",\n        \"other\": \"{count} cats\"\n    }\n}\n</code></pre></p> <p><code>locales/en.xml</code>: <pre><code>&lt;locale&gt;\n    &lt;cat&gt;\n        &lt;one&gt;{count} cat&lt;/one&gt;\n        &lt;other&gt;{count} cats&lt;/other&gt;\n    &lt;/cat&gt;\n&lt;/locale&gt;\n</code></pre></p> <p>Usage:</p> <pre><code>from doti18n import LocaleData\n\ni18n = LocaleData(\"locales\")\n\nprint(i18n[\"en\"].cat(1))   # Output: 1 cat\nprint(i18n[\"en\"].cat(3))   # Output: 3 cats\nprint(i18n[\"en\"].cat(11))  # Output: 11 cats\n</code></pre>"},{"location":"usage/pluralization/#with-variables","title":"With Variables","text":"<p>You can mix pluralization with variable interpolation. Use standard Python formatting <code>{variable}</code> inside the strings and pass values as keyword arguments.</p> YAMLJSONXML <p><code>locales/en.yaml</code>: <pre><code>cat:\n    one: \"{count} {color} cat\"\n    other: \"{count} {color} cats\"\n</code></pre></p> <p><code>locales/en.json</code>: <pre><code>{\n    \"cat\": {\n        \"one\": \"{count} {color} cat\",\n        \"other\": \"{count} {color} cats\"\n    }\n}\n</code></pre></p> <p><code>locales/en.xml</code>: <pre><code>&lt;locale&gt;\n    &lt;cat&gt;\n        &lt;one&gt;{count} {color} cat&lt;/one&gt;\n        &lt;other&gt;{count} {color} cats&lt;/other&gt;\n    &lt;/cat&gt;\n&lt;/locale&gt;\n</code></pre></p> <p>Usage:</p> <pre><code>from doti18n import LocaleData\n\ni18n = LocaleData(\"locales\")\n\nprint(i18n[\"en\"].cat(1, color=\"black\"))  # Output: 1 black cat\nprint(i18n[\"en\"].cat(4, color=\"white\"))  # Output: 4 white cats\nprint(i18n[\"en\"].cat(7, color=\"grey\"))   # Output: 7 grey cats\n</code></pre>"},{"location":"usage/supported_formats/","title":"Supported Formats","text":"YAMLJSONXML <p>Supports YAML via PyYAML. To enable YAML support, ensure the library is installed with the extra dependency: <pre><code>pip install doti18n[yaml]\n</code></pre></p> Note <p>You can also install <code>PyYAML</code> separately if doti18n is already installed.</p> <p>Files must have a <code>.yaml</code> or <code>.yml</code> extension.</p> <p>Supports JSON via the built-in <code>json</code> module. Included by default; no additional installation required.</p> <p>Files must have a <code>.json</code> extension.</p> <p>Supports XML via the built-in <code>xml</code> module. Included by default; no additional installation required.</p> <p>Files must have a <code>.xml</code> extension.</p>"},{"location":"usage/supported_formats/#structure-examples","title":"Structure Examples","text":"YAMLJSONXML <p><code>locales/en.yaml</code>:</p> <pre><code># key-value\nhello: \"Hello World!\"\n\n# list\nfruits:\n    - \"Apple\"\n    - \"Banana\"\n    - \"Orange\"\n\n# nested list\nitems:\n    - name: \"Item 1\" \n    - name: \"Item 2\"\n\n# nested dict\nerrors:\n    connection: \"Connection error occurred.\"\n    timeout: \"Request timed out.\"\n\n# pluralization\nnotifications:\n    one: \"You have {count} new notification.\"\n    other: \"You have {count} new notifications.\"\n</code></pre> <p>Note</p> <p>Standard YAML features (anchors, aliases, complex structures) are fully supported.</p> <p><code>locales/en.json</code>: <pre><code>{\n    // key-value\n    \"hello\": \"Hello World!\",\n\n    // list\n    \"fruits\": [\n        \"Apple\",\n        \"Banana\",\n        \"Orange\"\n    ],        \n\n    // nested list\n    \"items\": [\n        {\"name\": \"Item 1\"},\n        {\"name\": \"Item 2\"}\n    ],\n\n    // nested dict\n    \"errors\": {\n        \"connection\": \"Connection error occurred.\",\n        \"timeout\": \"Request timed out.\"\n    },\n\n    // pluralization\n    \"notifications\": {\n        \"one\": \"You have {count} new notification.\",\n        \"other\": \"You have {count} new notifications.\"\n    }\n}\n</code></pre></p> <p>Note</p> <p>Standard JSON does not support comments. The comments above are for illustration only.</p> <p><code>locales/en.xml</code>: <pre><code>&lt;locale&gt;\n    &lt;!-- key-value --&gt;\n    &lt;hello&gt;Hello World!&lt;/hello&gt;\n\n    &lt;!-- list --&gt;\n    &lt;fruits list=\"true\"&gt;\n        &lt;fruit&gt;Apple&lt;/fruit&gt;\n        &lt;fruit&gt;Banana&lt;/fruit&gt;\n        &lt;fruit&gt;Orange&lt;/fruit&gt;\n    &lt;/fruits&gt;\n\n    &lt;!-- nested list --&gt;\n    &lt;items list=\"true\"&gt;\n        &lt;item&gt;\n            &lt;name&gt;Item 1&lt;/name&gt;\n        &lt;/item&gt;\n        &lt;item&gt;\n            &lt;name&gt;Item 2&lt;/name&gt;\n        &lt;/item&gt;\n    &lt;/items&gt;\n\n    &lt;!-- nested dict --&gt;\n    &lt;errors&gt;\n        &lt;connection&gt;Connection error occurred.&lt;/connection&gt;\n        &lt;timeout&gt;Request timed out.&lt;/timeout&gt;\n    &lt;/errors&gt;\n\n    &lt;!-- pluralization --&gt;\n    &lt;notifications&gt;\n        &lt;one&gt;You have {count} new notification.&lt;/one&gt;\n        &lt;other&gt;You have {count} new notifications.&lt;/other&gt;\n    &lt;/notifications&gt;\n&lt;/locale&gt;\n</code></pre></p> <p>XML Parsing Logic</p> <ul> <li>Root Element: Ignored. You can name it anything (e.g., <code>&lt;locale&gt;</code>, <code>&lt;data&gt;</code>, <code>&lt;xml&gt;</code>), it serves only as a container.</li> <li>Lists: Tags with identical child names are automatically treated as lists.</li> <li>Explicit Lists: To force a list (e.g., for a single element), add the <code>list=\"true\"</code> attribute to the parent tag. Using <code>list=\"true\"</code> explicitly is recommended for consistency.</li> </ul>"},{"location":"usage/supported_formats/#multilocale-files","title":"Multilocale Files","text":"<p>doti18n supports defining multiple locales in a single file.  </p> <p>Warning</p> <p>Using multilocale files is discouraged as it increases maintenance complexity. Separate files per locale are recommended.</p> YAMLJSONXML <p>Each document must contain a <code>locale</code> key (this key is removed from the final data). Missing keys will trigger an error (or a log in non-strict mode).</p> <p><code>locales/locales.yaml</code>: <pre><code>locale: \"en\"\nhello: \"Hello World!\"\n---\nlocale: \"fr\"\nhello: \"Bonjour le monde!\"\n</code></pre></p> <p>Warning</p> <p>Any YAML file containing multiple documents (separated by <code>---</code>) is treated as a multilocale file.</p> <p>Each object in the root list must contain a <code>locale</code> key (this key is removed from the final data). Missing keys will trigger an error (or a log in non-strict mode).</p> <p><code>locales/locales.json</code>: <pre><code>[\n    {\n        \"locale\": \"en\",\n        \"hello\": \"Hello World!\"\n    }, \n    {\n        \"locale\": \"fr\",\n        \"hello\": \"Bonjour le monde!\"\n    }\n]\n</code></pre></p> <p>Warning</p> <p>Any JSON file where the root element is a list is treated as a multilocale file.</p> <p>The root element must be <code>&lt;locales&gt;</code>, <code>&lt;localizations&gt;</code>, or <code>&lt;translations&gt;</code>. Child tags serve as locale names (see example). Incorrect structure will trigger an error (or a log in non-strict mode).</p> <p><code>locales/locales.xml</code>: <pre><code>&lt;locales&gt;\n    &lt;en&gt;\n        &lt;hello&gt;Hello World!&lt;/hello&gt;\n    &lt;/en&gt;\n    &lt;fr&gt;\n        &lt;hello&gt;Bonjour le monde!&lt;/hello&gt;\n    &lt;/fr&gt;\n&lt;/locales&gt;\n</code></pre></p> <p>Warning</p> <p>Any XML file with a root element named <code>&lt;locales&gt;</code>, <code>&lt;localizations&gt;</code>, or <code>&lt;translations&gt;</code> is treated as a multilocale file.</p>"},{"location":"usage/supported_formats/#usage-example","title":"Usage Example","text":"<pre><code>from doti18n import LocaleData\n\ni18n = LocaleData(\"locales\")\nprint(i18n[\"en\"].hello)  # Output: Hello World!\nprint(i18n[\"fr\"].hello)  # Output: Bonjour le monde!\n</code></pre>"}]}